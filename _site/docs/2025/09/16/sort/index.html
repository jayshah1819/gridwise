<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Gridwise Sort | Gridwise</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Gridwise Sort" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Learn about Gridwise’s GPU radix sort implementation using OneSweep architecture for high-performance sorting." />
<meta property="og:description" content="Learn about Gridwise’s GPU radix sort implementation using OneSweep architecture for high-performance sorting." />
<link rel="canonical" href="http://localhost:4000/gridwise/docs/2025/09/16/sort/" />
<meta property="og:url" content="http://localhost:4000/gridwise/docs/2025/09/16/sort/" />
<meta property="og:site_name" content="Gridwise" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-09-16T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Gridwise Sort" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-09-16T00:00:00-04:00","datePublished":"2025-09-16T00:00:00-04:00","description":"Learn about Gridwise’s GPU radix sort implementation using OneSweep architecture for high-performance sorting.","headline":"Gridwise Sort","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/gridwise/docs/2025/09/16/sort/"},"url":"http://localhost:4000/gridwise/docs/2025/09/16/sort/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/gridwise/docs/assets/css/style.css"></head>
<body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/gridwise/%20/">Gridwise</a><nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewBox="0 0 18 15" width="18px" height="15px">
            <path
              d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.484C18,14.304,17.335,14.969,16.516,14.969H1.484 C0.665,14.969,0,14.304,0,13.484l0,0C0,12.665,0.665,12,1.484,12h15.032C17.335,12,18,12.665,18,13.484L18,13.484z" />
          </svg>
        </span>
      </label>

      <div class="trigger"><a class="button" href="/gridwise/%20/examples-guide/">Example Docs</a>
        <a class="button" href="/gridwise/%20/">Read Docs</a>
        <a class="button" href="javascript:void(0)" onclick="launchExample()">Try Interactive Example</a>
      </div>
    </nav></div>
</header>

<script>
  function launchExample() {
    window.open('https://gridwise-webgpu.github.io/gridwise/examples/scan_pane_example.html', '_blank');
  }
</script><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Gridwise Sort</h1>
    <div class="post-meta">
      <time class="dt-published" datetime="2025-09-16T00:00:00-04:00" itemprop="datePublished">
        Sep 16, 2025
      </time>
    </div>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>The dominant approach to GPU sorting is a <a href="https://en.wikipedia.org/wiki/Radix_sort">radix sort</a> over input keys. In general, radix sorts deliver high performance on GPUs because they require <em>O(n)</em> work for inputs of <em>n</em> elements, because their constituent memory accesses are generally fairly coalesced and thus deliver good memory performance, and because the underlying compute primitives that compose to make the sort are good matches for GPUs.</p>

<p>The specific sort architecture we choose is <a href="https://research.nvidia.com/publication/2022-06_onesweep-faster-least-significant-digit-radix-sort-gpus">OneSweep</a>, developed by Andrey Adinets and Duane Merrill of NVIDIA. Internally, OneSweep uses a chained scan, as does our implementation. The challenges we outlined in our <a href="scan-and-reduce.html#decoupled-lookback-and-forward-progress-guarantees">scan description</a> with respect to forward-progress guarantees are the same. Our sort implementation employs both lookback and fallback to ensure that it will work on GPUs that lack forward-progress guarantees.</p>

<h2 id="our-sort-implementation">Our Sort Implementation</h2>

<p>At its heart, radix sort computes a permutation of its input values and then performs the permutation. Computing the entire permutation would be intractable (the size of the intermediate data structures would be enormous), so typically a radix sort makes several passes over the input, each time computing a permutation for a subset of input bits (this subset is called a “digit”). OneSweep begins with the least significant bits, as do we. Our implementation considers 8 bits per pass, meaning each digit can take on 2^8 = 256 possible values. We thus require 4 passes to sort 32-bit keys. On each pass, we classify the key into one of 256 “buckets” based on its digit value. The permutation we want to compute will always place keys with lower digit values before keys with higher digit values.</p>

<p>As with scan, we divide the input into equal-sized “tiles” and assign one workgroup to each tile.</p>

<p>Computing this permutation means computing a “destination address” for each key—to where in the output will this key be written? That address is the sum of:</p>

<ol>
  <li>The number of keys that fall into a bucket before my bucket</li>
  <li>The number of keys that are in my bucket and are processed in a previous tile</li>
  <li>The number of keys that are in my bucket and are processed earlier than
my key within my tile</li>
</ol>

<p>We compute (1) by constructing a global histogram of all bucket sizes (kernel: <code class="language-plaintext highlighter-rouge">global_hist</code>, which constructs a separate histogram for each digit) and then running exclusive-sum-scan on these histograms (kernel: <code class="language-plaintext highlighter-rouge">onesweep_scan</code>).</p>

<p>We compute (2) by first computing the number of keys per bucket within my histogram and then using a chained sum scan to retrieve the sum of the sizes of the previous workgroup’s buckets (kernel: <code class="language-plaintext highlighter-rouge">onesweep_pass</code>). We add in (1) at the start of this chained scan, so we actually chained-scan (1) + (2). The chained scan requires lookback to look at the results of this scan, and if the hardware does not offer forward-progress guarantees, the chained scan also requires fallback to redundantly compute this value. We compute (3) in <code class="language-plaintext highlighter-rouge">onesweep_pass</code> as well, but it is workgroup-local only; it does not participate in the chained-scan.</p>

<p>Given this computed address per key, we could directly scatter each key to its location in global memory. However, to improve memory coalescing, we first write keys into workgroup memory and scatter from there. This puts neighboring keys next to each other in workgroup memory and significantly improves the throughput of the global scatter.</p>

<p>Note that the chained scan in onesweep is a chained scan over an entire 256-entry histogram. Lookback on such a large data structure is more complicated than lookback on a single data value, as we see in <a href="scan-and-reduce.html">our scan implementation</a>, because we use an entire workgroup to look back. The additional complexity is that <em>any</em> thread in the lookback may fail to find a ready value, and if this is the case, the entire workgroup must drop into fallback. Thus we have to keep track of both per-thread lookback success as well as per-subgroup lookback success, and only determine lookback is successful if all subgroups report success.</p>

<p>Radix sort implementations (including ours) typically use a ping-pong pair of arrays: on each pass, one array is the input and one array is the output, and on each pass, their roles switch. Because we are sorting 32- or 64-bit keys at 8 bits per pass, this means the input will be overwritten by the output and the primitive’s output will be produced in the same buffer as its original input. Overwriting the input is not ideal behavior but is probably preferable to approaches that hide it from the user (by, say, preemptively copying the input into a temporary buffer and copying the temporary input and output at the end of the computation).</p>

<h2 id="configuring-and-calling-gridwise-sort">Configuring and Calling Gridwise Sort</h2>

<h3 id="defining-the-primitive">Defining the primitive</h3>

<p>Declare the scan or reduce primitive as an instance of the <code class="language-plaintext highlighter-rouge">OneSweepSort</code> class.  An example scan declaration:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">datatype</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">u32</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// or "i32" or "f32"</span>
<span class="kd">const</span> <span class="nx">oneSweepSortPrimitive</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">OneSweepSort</span><span class="p">({</span>
  <span class="nx">device</span><span class="p">,</span>
  <span class="nx">datatype</span><span class="p">,</span> <span class="c1">// use the "datatype" string defined above</span>
  <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">keysonly</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">direction</span><span class="p">:</span> <span class="dl">"</span><span class="s2">ascending</span><span class="dl">"</span><span class="p">,</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Gridwise OneSweep supports all combinations of:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">datatype</code>: <code class="language-plaintext highlighter-rouge">u32</code>, <code class="language-plaintext highlighter-rouge">i32</code>, <code class="language-plaintext highlighter-rouge">f32</code>, <code class="language-plaintext highlighter-rouge">u64</code>. Internally, OneSweep converts non-unsigned-int keys into unsigned-int keys that respect the original order, sorts as if the keys were unsigned ints, and then reverses the conversion when writing the keys into the output.</li>
  <li><code class="language-plaintext highlighter-rouge">type</code>: <code class="language-plaintext highlighter-rouge">keysonly</code>, <code class="language-plaintext highlighter-rouge">keyvalue</code>. A key-value sort has an array of keys and also an array of values where each value is associated with its corresponding key in the keys array. Default: <code class="language-plaintext highlighter-rouge">keysonly</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">direction</code>: <code class="language-plaintext highlighter-rouge">ascending</code>, <code class="language-plaintext highlighter-rouge">descending</code>. The default is <code class="language-plaintext highlighter-rouge">ascending</code> (sort low to high), but we support sorting in the other direction as well.</li>
</ul>

<h3 id="configuring-the-primitive">Configuring the primitive</h3>

<p>Once the primitive is <em>defined</em>, it must then be <em>configured</em>. The primitive knows that it requires an input/output and temporary buffer, labeled <code class="language-plaintext highlighter-rouge">keysInOut</code> and <code class="language-plaintext highlighter-rouge">keysTemp</code>. (We use our <a href="buffer.html"><code class="language-plaintext highlighter-rouge">Buffer</code> class</a> for this.) If we are doing a key-value sort, we also require <code class="language-plaintext highlighter-rouge">payloadInOut</code> and <code class="language-plaintext highlighter-rouge">payloadTemp</code> buffers, which store the values.) We configure the primitive by registering data buffers with the primitive. This can be done either with a <code class="language-plaintext highlighter-rouge">primitive.registerBuffer()</code> call or as an argument to the <code class="language-plaintext highlighter-rouge">execute</code> call. (The former is preferred if we need to register the buffer(s) once and then call <code class="language-plaintext highlighter-rouge">execute</code> many times.)</p>

<p>To register a buffer, simply call <code class="language-plaintext highlighter-rouge">primitive.registerBuffer(buffer)</code>, where <code class="language-plaintext highlighter-rouge">buffer.label</code> is one of the buffers above. The below code creates a <code class="language-plaintext highlighter-rouge">Buffer</code> then registers it.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">inputLength</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">20</span><span class="p">;</span>
<span class="nx">testKeysBuffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Buffer</span><span class="p">({</span>
  <span class="nx">device</span><span class="p">,</span>
  <span class="na">datatype</span><span class="p">:</span> <span class="dl">"</span><span class="s2">f32</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">length</span><span class="p">:</span> <span class="nx">inputLength</span><span class="p">,</span>
  <span class="na">label</span><span class="p">:</span> <span class="dl">"</span><span class="s2">keysInOut</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">createCPUBuffer</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">initializeCPUBuffer</span><span class="p">:</span> <span class="kc">true</span> <span class="cm">/* fill with default data */</span><span class="p">,</span>
  <span class="na">storeCPUBackup</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="cm">/* because readback will overwrite the CPU data */</span>
  <span class="na">createGPUBuffer</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">initializeGPUBuffer</span><span class="p">:</span> <span class="kc">true</span> <span class="cm">/* with CPU data */</span><span class="p">,</span>
  <span class="na">createMappableGPUBuffer</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="cm">/* we read this back to test correctness */</span>
<span class="p">});</span>
<span class="nx">oneSweepSortPrimitive</span><span class="p">.</span><span class="nx">registerBuffer</span><span class="p">(</span><span class="nx">testKeysBuffer</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="calling-scan-or-reduce">Calling scan or reduce</h3>

<p>Once the primitive is defined and configured, simply call its <code class="language-plaintext highlighter-rouge">execute()</code> method.</p>

<p>If you have not yet registered buffers, you can specify them in the argument object as <code class="language-plaintext highlighter-rouge">keysInOut</code>, <code class="language-plaintext highlighter-rouge">keysTemp</code>, etc.</p>

<p>Other possible arguments (which are timing-specific and thus which you are unlikely to use unless you are benchmarking) are:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">trials</code> with an integer argument. This will run the kernel(s) that number of times. Default: 1.</li>
  <li><code class="language-plaintext highlighter-rouge">enableGPUTiming</code> with either true or false. If true, please ensure that the device has a set of required features that include <code class="language-plaintext highlighter-rouge">timestamp-query</code>. Default: false.</li>
  <li><code class="language-plaintext highlighter-rouge">enableCPUTiming</code> with either true or false. Default: false.</li>
</ul>

<p>Note that <code class="language-plaintext highlighter-rouge">execute()</code> is declared <code class="language-plaintext highlighter-rouge">async</code>.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">await</span> <span class="nx">oneSweepSortPrimitive</span><span class="p">.</span><span class="nx">execute</span><span class="p">();</span>
<span class="c1">// or, if we want to specify buffers only when execute is called</span>
<span class="k">await</span> <span class="nx">oneSweepSortPrimitive</span><span class="p">.</span><span class="nx">execute</span><span class="p">({</span>
  <span class="na">keysInOut</span><span class="p">:</span> <span class="nx">testKeysBuffer</span><span class="p">,</span>
  <span class="na">keysTemp</span><span class="p">:</span> <span class="nx">testKeysTempBuffer</span><span class="p">,</span>
<span class="p">});</span>
<span class="c1">// or (maybe if you're benchmarking)</span>
<span class="k">await</span> <span class="nx">oneSweepSortPrimitive</span><span class="p">.</span><span class="nx">execute</span><span class="p">({</span>
  <span class="na">trials</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">enableGPUTiming</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="na">enableCPUTiming</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
<span class="p">});</span>
</code></pre></div></div>

<h2 id="usage-and-performance-notes">Usage and performance notes</h2>

<p>The number of items to sort must be no greater than 2^30. (CUB does the same thing.) We use the two most-significant bits as status bits. It would take a large engineering effort to remove this limitation.</p>

<p>Just as with scan, input lengths <em>must be</em> a multiple of 4. Pad the end of your input array with enough largest-key-value elements to make this work. (This is because internally, we use <code class="language-plaintext highlighter-rouge">vec4</code>s for computation.)</p>

<p>During its development, sort had extensive performance testing and the defaults are fairly stable across different GPUs. We sort 8 bits per pass and this particular implementation has never been tested with a different number of bits per pass. This could be remedied with engineering effort.</p>

  </div>

  <a class="u-url" href="/gridwise/docs/2025/09/16/sort/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
    <data class="u-url" href="/gridwise/%20/"></data>

    <div class="wrapper">
        <h2 class="footer-heading">Gridwise</h2>

        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Gridwise</li><li><a class="u-email" href="mailto:jowens@ece.ucdavis.edu">jowens@ece.ucdavis.edu</a></li></ul>
            </div>

            <div class="footer-col footer-col-3">
                <p>WebGPU compute primitives in JavaScript</p>
            </div>
        </div>

    </div>

</footer>
</body>

</html>
